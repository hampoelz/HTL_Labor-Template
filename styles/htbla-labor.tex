\begin{sagesilent}
    from sage.structure.element import is_Vector, is_Matrix

    def norm(x, n=None):
        # convert number to decimal or scientific format based on complexity 
        general_format = lambda x: '{:g}'.format(float(x))

        # calculate digits of a number to the right and left of the decimal point
        def numerical_approx_length(x):
            value = general_format(x)
            if 'e' in value: value = value.split('e')[0]
            length = [len(value), 1] # 1 = default number of decimal places
            if '.' in value:
                value = value.split('.')
                r_len = 0 if value[0] == '0' else len(value[0])
                l_len = n or len(value[1]) # Use custom 'n' decimals if defined
                length = [r_len, l_len]
            return length
        
        # calculate digits of a complex number or a number
        def approx_length(x):
            if hasattr(x, 'real') and hasattr(x, 'imag') and x.imag():
                # The real and imaginary parts of a complex number have the same number of decimal places,
                # so that no decimals are truncated later, the part with the most digits is used
                len_real = numerical_approx_length(x.real())
                len_imag = numerical_approx_length(x.imag())
                return max(len_real[0], len_imag[0]) + max(len_real[1], len_imag[1])
            return sum(numerical_approx_length(x))
        
        # format a number for better readability
        def approx(x, length=None, allow_str=False):
            if not length:
                length = approx_length(x)
            
            # handle complex numbers
            if hasattr(x, 'real') and hasattr(x, 'imag') and x.imag():
                return numerical_approx(x, digits=length)
            
            # handle numbers

            # converting to the general format has some disadvantages:
            # - accepts only data types that can be cast to float
            # - causes problems with vectors and matrices, which do not accept strings
            # - decimals are truncated depending on complexity (problematic when 'n' of decimals are desired)
            # - the scientific form of numbers is not correctly rendered in LaTeX
            # therefore, the number is only converted if the above problems do not apply
            value = general_format(x)
            if allow_str and not n and 'e' not in value:
                return value
            
            return numerical_approx(x, digits=length)

        # handle vectors
        if is_Vector(x):
            v, v_len = [], []
            # use the point with the most digits since each point will have the same number of decimal places in the vector
            for i in range(len(x)):
                v_len.append(approx_length(x[i]))
            # beautify every point of the vector and create a new vector
            for i in range(len(x)):
                v.append(approx(x[i], length=max(v_len)))
            return vector(v)
        
        # handle matrices
        if is_Matrix(x):
            m, m_len = [], []
            # use the point with the most digits since each point will have the same number of decimal places in the matrix
            for i in range(x.nrows()):
                for j in range(x.ncols()):
                    m_len.append(approx_length(x[i][j]))
            # beautify every point of the matrix and create a new matrix
            for i in range(x.nrows()):
                m.append([])
                for j in range(x.ncols()):
                    m[i].append(approx(x[i][j], length=max(m_len)))
            return matrix(m)

        # handle numbers
        return approx(x, allow_str=True)

    import numpy as np
    from scipy import interpolate
    from scipy import ndimage

    class Measures:
        def __init__(self, titles, values):
            self.titles = titles
            self.rows = values
            self.columns = list(zip(*values))
            self.table = table(values, header_row=titles, frame=true, align='center')
        def plot_data(self, x_index, y_index):
            x = self.columns[x_index]
            y = self.columns[y_index]
            data = list(zip(x,y))
            return data
        def g1d_filter(self, x_index, y_index, sigma = 2):
            x_column, y_column = zip(*self.plot_data(x_index, y_index))

            x = [float(x) for x in x_column]
            y = [float(y) for y in y_column]
            data = list(zip(x,y))

            x_sm = np.array(x)
            y_sm = np.array(y)

            x_g1d = ndimage.gaussian_filter1d(x_sm, sigma)
            y_g1d = ndimage.gaussian_filter1d(y_sm, sigma)
            g1d_data = list(zip(x_g1d,y_g1d))
            return g1d_data
        def smooth_data(self, data, filter_data, num=300, connect=False):   
            x_filter, y_filter = zip(*filter_data)
            
            x_sm = np.array(x_filter)
            y_sm = np.array(y_filter)

            g1d_smooth = np.linspace(x_sm.min(), x_sm.max(), num)
            g1d_spline = interpolate.InterpolatedUnivariateSpline(x_sm, y_sm)

            data_smooth = list(zip(g1d_smooth, g1d_spline(g1d_smooth)))
            if connect:
                data_smooth.insert(0, data[0])
                data_smooth.append(data[-1])
            return data_smooth
        def g1d_smooth(self, x_index, y_index, sigma = 2, num = 300, connect=False):
            x_column, y_column = zip(*self.plot_data(x_index, y_index))
            
            x = [float(x) for x in x_column]
            y = [float(y) for y in y_column]
            data = list(zip(x,y))
            
            filter_data = self.g1d_filter(x_index, y_index, sigma)
            smooth_data = self.smooth_data(data, filter_data, num, connect)
            return smooth_data

    from scipy import signal

    class Bode:
        def __init__(self, expr, freq_start, freq_stop, freq_steps):
            self.expr = expr
            self.freq = np.linspace(freq_start, freq_stop, num=round((freq_stop-freq_start)/freq_steps))
            self.omeg = 2*np.pi*self.freq
            self.sys = self.expr_to_system()
            self.data = signal.bode(self.sys, self.omeg)
        def expr_to_system(self):
            expr = self.expr    # eg. (L*s)/(R+L*s)

            # convert expression to a fraction with real numbers for numerical evaluation
            expr = expr._convert(FractionField(RR))

            # extract numerator and denominator
            expr_u = expr.numerator()    # -> (L*s+0)
            expr_v = expr.denominator()  # -> (R+L*s)

            # convert expressions to complex numbers
            expr_u = expr_u.substitute(s=I)
            expr_v = expr_v.substitute(s=I)
            expr_u = expr_u._convert(CC)
            expr_v = expr_v._convert(CC)

            # separate the real and imaginary parts and convert to floats
            u_imag = float(expr_u.imag())
            v_imag = float(expr_v.imag())
            u_real = float(expr_u.real())
            v_real = float(expr_v.real())

            # create a linear time invariant system
            return signal.TransferFunction([u_imag, u_real], [v_imag, v_real])
        def plot_data_omeg_mag(self):
            w, mag_dB, pha = self.data
            return list(zip(w, mag_dB))
        def plot_data_omeg_pha(self):
            w, mag_dB, pha = self.data
            return list(zip(w, pha))
        def plot_data_freq_mag(self):
            f = self.freq
            w, mag_dB, pha = self.data
            return list(zip(f, mag_dB))
        def plot_data_freq_pha(self):
            f = self.freq
            w, mag_dB, pha = self.data
            return list(zip(f, pha))

\end{sagesilent}